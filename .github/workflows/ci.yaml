name: CI

on:
  push:
    branches: [ main ]          # dev deploy on merges to main
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  deploy-dev:
    runs-on: ubuntu-latest
    environment: dev
    env:
      AWS_REGION: ${{ vars.AWS_REGION }}
      ECR_REGISTRY_HOST: ${{ vars.ECR_REGISTRY_HOST }}   # host only, no trailing slash
      ECR_REPO: ${{ vars.ECR_REPO }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Configure AWS (dev)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Ensure ECR repository exists (dev)
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_REPO:   ${{ env.ECR_REPO }}
        run: |
          set -euo pipefail

          echo "Checking for ECR repository: $ECR_REPO in $AWS_REGION"

          if aws ecr describe-repositories \
                --repository-names "$ECR_REPO" \
                --region "$AWS_REGION" >/dev/null 2>&1; then
            echo "ECR repository $ECR_REPO already exists"
          else
            echo "ECR repository $ECR_REPO does not exist, creating..."
            aws ecr create-repository \
              --repository-name "$ECR_REPO" \
              --region "$AWS_REGION" \
              --image-scanning-configuration scanOnPush=true \
              --encryption-configuration encryptionType=AES256
          fi

      - name: Login to ECR (dev)
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
          | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY_HOST }}

      - name: Compute image ref
        id: meta
        run: |
          set -euo pipefail
          TAG="dev-${GITHUB_SHA}"
          IMAGE="${{ env.ECR_REGISTRY_HOST }}/${{ env.ECR_REPO }}:${TAG}"
          case "$IMAGE" in *.amazonaws.com/*:*) ;; *) echo "::error ::IMAGE malformed: $IMAGE"; exit 1 ;; esac
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "Using dev image: $IMAGE"

      - name: Check if tag exists (dev)
        id: ecrcheck
        run: |
          if aws ecr describe-images \
               --repository-name "${{ env.ECR_REPO }}" \
               --image-ids imageTag="${{ steps.meta.outputs.tag }}" \
               --region "${{ env.AWS_REGION }}" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Build & push (if missing)
        if: steps.ecrcheck.outputs.exists == 'false'
        run: |
          docker build -t "${{ steps.meta.outputs.image }}" app
          docker push "${{ steps.meta.outputs.image }}"

      - name: Terraform init/plan/apply (dev)
        working-directory: terraform
        env:
          TF_VAR_env: dev
          TF_VAR_image: ${{ steps.meta.outputs.image }}
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
        run: |
          rm -rf .terraform
          terraform init -input=false -reconfigure -backend-config=backend/dev.hcl
          terraform plan -input=false -var-file=tfvars/dev.tfvars -out=tfplan
          terraform apply -input=false -auto-approve tfplan

  promote-and-deploy-prod:
    runs-on: ubuntu-latest
    needs: deploy-dev
    environment: prod
    env:
      # prod (target) – values come from prod environment
      PROD_AWS_REGION: ${{ vars.AWS_REGION }}
      PROD_ROLE_ARN:   ${{ vars.AWS_ROLE_ARN }}
      PROD_ECR_HOST:   ${{ vars.ECR_REGISTRY_HOST }}
      ECR_REPO:        ${{ vars.ECR_REPO }}
      # dev (source) – use the dev environment values explicitly
      DEV_AWS_REGION:  ${{ vars.AWS_REGION }}            # if dev/prod regions differ, set per-env
      DEV_ECR_HOST:    ${{ vars.DEV_ECR_HOST }}          # var in repo/global
      DEV_ROLE_ARN:    ${{ vars.DEV_AWS_ROLE_ARN }}      # var in repo/global
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Define image refs
        id: img
        run: |
          set -euo pipefail
          DEV_IMAGE="${{ env.DEV_ECR_HOST }}/${{ env.ECR_REPO }}:dev-${GITHUB_SHA}"
          PROD_IMAGE="${{ env.PROD_ECR_HOST }}/${{ env.ECR_REPO }}:prod-${GITHUB_SHA}"
          for v in DEV_IMAGE PROD_IMAGE; do
            val="${!v}"
            case "$val" in *.amazonaws.com/*:*) ;; *) echo "::error ::$v malformed: $val"; exit 1 ;; esac
            echo "$v=$val"
          done
          echo "DEV_IMAGE=$DEV_IMAGE"   >> $GITHUB_OUTPUT
          echo "PROD_IMAGE=$PROD_IMAGE" >> $GITHUB_OUTPUT

      # 1) Assume DEV role, pull the built image from dev ECR
      - name: Configure AWS (dev)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.DEV_ROLE_ARN }}
          aws-region: ${{ env.DEV_AWS_REGION }}

      - name: Login & pull (DEV)
        run: |
          aws ecr get-login-password --region "${{ env.DEV_AWS_REGION }}" \
          | docker login --username AWS --password-stdin "${{ env.DEV_ECR_HOST }}"
          docker pull "${{ steps.img.outputs.DEV_IMAGE }}"

      # 2) Assume PROD role
      - name: Configure AWS (prod)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.PROD_ROLE_ARN }}
          aws-region: ${{ env.PROD_AWS_REGION }}

      - name: Login (PROD)
        run: |
          aws ecr get-login-password --region "${{ env.PROD_AWS_REGION }}" \
          | docker login --username AWS --password-stdin "${{ env.PROD_ECR_HOST }}"

      # 3) Push only if immutable tag doesn't exist
      - name: Check if prod tag exists
        id: prod_tag
        run: |
          if aws ecr describe-images \
            --repository-name "${{ env.ECR_REPO }}" \
            --image-ids imageTag="prod-${GITHUB_SHA}" \
            --region "${{ env.PROD_AWS_REGION }}" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Promote image to PROD (if missing)
        if: steps.prod_tag.outputs.exists == 'false'
        run: |
          docker tag  "${{ steps.img.outputs.DEV_IMAGE }}" "${{ steps.img.outputs.PROD_IMAGE }}"
          docker push "${{ steps.img.outputs.PROD_IMAGE }}"

      # 4) Terraform deploy (prod) with the immutable image ref
      - name: Terraform apply (prod)
        working-directory: terraform
        env:
          TF_VAR_env:       prod
          TF_VAR_image:     ${{ steps.img.outputs.PROD_IMAGE }}
          TF_VAR_aws_region: ${{ env.PROD_AWS_REGION }}
        run: |
          rm -rf .terraform
          terraform init -input=false -reconfigure -backend-config=backend/prod.hcl
          terraform plan -input=false -var-file=tfvars/prod.tfvars -out=tfplan
          terraform apply -input=false -auto-approve tfplan